// Code generated by gotsrpc https://github.com/foomo/gotsrpc  - DO NOT EDIT.

package edit

import (
	http "net/http"
	time "time"

	gotsrpc "github.com/foomo/gotsrpc"
	github_com_janhalfar_vocablion_services "github.com/janhalfar/vocablion/services"
)

type ServiceGoTSRPCProxy struct {
	EndPoint    string
	allowOrigin []string
	service     *Service
}

func NewDefaultServiceGoTSRPCProxy(service *Service, allowOrigin []string) *ServiceGoTSRPCProxy {
	return &ServiceGoTSRPCProxy{
		EndPoint:    "/service/edit",
		allowOrigin: allowOrigin,
		service:     service,
	}
}

func NewServiceGoTSRPCProxy(service *Service, endpoint string, allowOrigin []string) *ServiceGoTSRPCProxy {
	return &ServiceGoTSRPCProxy{
		EndPoint:    endpoint,
		allowOrigin: allowOrigin,
		service:     service,
	}
}

// ServeHTTP exposes your service
func (p *ServiceGoTSRPCProxy) ServeHTTP(w http.ResponseWriter, r *http.Request) {

	for _, origin := range p.allowOrigin {
		// todo we have to compare this with the referer ... and only send one
		w.Header().Add("Access-Control-Allow-Origin", origin)
	}
	w.Header().Set("Access-Control-Allow-Credentials", "true")
	if r.Method != http.MethodPost {
		if r.Method == http.MethodOptions {
			return
		}
		gotsrpc.ErrorMethodNotAllowed(w)
		return
	}

	var args []interface{}
	funcName := gotsrpc.GetCalledFunc(r, p.EndPoint)
	callStats := gotsrpc.GetStatsForRequest(r)
	if callStats != nil {
		callStats.Func = funcName
		callStats.Package = "github.com/janhalfar/vocablion/services/edit"
		callStats.Service = "Service"
	}
	switch funcName {
	case "AddTranslation":
		var (
			arg_translation string
		)
		args = []interface{}{&arg_translation}
		err := gotsrpc.LoadArgs(&args, callStats, r)
		if err != nil {
			gotsrpc.ErrorCouldNotLoadArgs(w)
			return
		}
		executionStart := time.Now()
		addTranslationState, addTranslationErr := p.service.AddTranslation(w, r, arg_translation)
		if callStats != nil {
			callStats.Execution = time.Now().Sub(executionStart)
		}
		gotsrpc.Reply([]interface{}{addTranslationState, addTranslationErr}, callStats, r, w)
		return
	case "DeleteTranslation":
		var (
			arg_translation string
		)
		args = []interface{}{&arg_translation}
		err := gotsrpc.LoadArgs(&args, callStats, r)
		if err != nil {
			gotsrpc.ErrorCouldNotLoadArgs(w)
			return
		}
		executionStart := time.Now()
		deleteTranslationState, deleteTranslationErr := p.service.DeleteTranslation(w, r, arg_translation)
		if callStats != nil {
			callStats.Execution = time.Now().Sub(executionStart)
		}
		gotsrpc.Reply([]interface{}{deleteTranslationState, deleteTranslationErr}, callStats, r, w)
		return
	case "LoadWord":
		var (
			arg_id string
		)
		args = []interface{}{&arg_id}
		err := gotsrpc.LoadArgs(&args, callStats, r)
		if err != nil {
			gotsrpc.ErrorCouldNotLoadArgs(w)
			return
		}
		executionStart := time.Now()
		loadWordState, loadWordErr := p.service.LoadWord(w, r, arg_id)
		if callStats != nil {
			callStats.Execution = time.Now().Sub(executionStart)
		}
		gotsrpc.Reply([]interface{}{loadWordState, loadWordErr}, callStats, r, w)
		return
	case "NewWord":
		var (
			arg_unit string
		)
		args = []interface{}{&arg_unit}
		err := gotsrpc.LoadArgs(&args, callStats, r)
		if err != nil {
			gotsrpc.ErrorCouldNotLoadArgs(w)
			return
		}
		executionStart := time.Now()
		newWordState, newWordErr := p.service.NewWord(w, r, arg_unit)
		if callStats != nil {
			callStats.Execution = time.Now().Sub(executionStart)
		}
		gotsrpc.Reply([]interface{}{newWordState, newWordErr}, callStats, r, w)
		return
	case "SaveWord":
		var ()
		args = []interface{}{}
		err := gotsrpc.LoadArgs(&args, callStats, r)
		if err != nil {
			gotsrpc.ErrorCouldNotLoadArgs(w)
			return
		}
		executionStart := time.Now()
		saveWordState, saveWordErr := p.service.SaveWord(w, r)
		if callStats != nil {
			callStats.Execution = time.Now().Sub(executionStart)
		}
		gotsrpc.Reply([]interface{}{saveWordState, saveWordErr}, callStats, r, w)
		return
	case "SetDeclination":
		var (
			arg_declination github_com_janhalfar_vocablion_services.Declination
		)
		args = []interface{}{&arg_declination}
		err := gotsrpc.LoadArgs(&args, callStats, r)
		if err != nil {
			gotsrpc.ErrorCouldNotLoadArgs(w)
			return
		}
		executionStart := time.Now()
		setDeclinationState, setDeclinationErr := p.service.SetDeclination(w, r, arg_declination)
		if callStats != nil {
			callStats.Execution = time.Now().Sub(executionStart)
		}
		gotsrpc.Reply([]interface{}{setDeclinationState, setDeclinationErr}, callStats, r, w)
		return
	case "SetGender":
		var (
			arg_gender github_com_janhalfar_vocablion_services.Gender
		)
		args = []interface{}{&arg_gender}
		err := gotsrpc.LoadArgs(&args, callStats, r)
		if err != nil {
			gotsrpc.ErrorCouldNotLoadArgs(w)
			return
		}
		executionStart := time.Now()
		setGenderState, setGenderErr := p.service.SetGender(w, r, arg_gender)
		if callStats != nil {
			callStats.Execution = time.Now().Sub(executionStart)
		}
		gotsrpc.Reply([]interface{}{setGenderState, setGenderErr}, callStats, r, w)
		return
	case "SetGenitive":
		var (
			arg_genitive string
		)
		args = []interface{}{&arg_genitive}
		err := gotsrpc.LoadArgs(&args, callStats, r)
		if err != nil {
			gotsrpc.ErrorCouldNotLoadArgs(w)
			return
		}
		executionStart := time.Now()
		setGenitiveState, setGenitiveErr := p.service.SetGenitive(w, r, arg_genitive)
		if callStats != nil {
			callStats.Execution = time.Now().Sub(executionStart)
		}
		gotsrpc.Reply([]interface{}{setGenitiveState, setGenitiveErr}, callStats, r, w)
		return
	case "SetType":
		var (
			arg_wordType github_com_janhalfar_vocablion_services.WordType
		)
		args = []interface{}{&arg_wordType}
		err := gotsrpc.LoadArgs(&args, callStats, r)
		if err != nil {
			gotsrpc.ErrorCouldNotLoadArgs(w)
			return
		}
		executionStart := time.Now()
		setTypeState, setTypeErr := p.service.SetType(w, r, arg_wordType)
		if callStats != nil {
			callStats.Execution = time.Now().Sub(executionStart)
		}
		gotsrpc.Reply([]interface{}{setTypeState, setTypeErr}, callStats, r, w)
		return
	case "SetUnit":
		var (
			arg_unit string
		)
		args = []interface{}{&arg_unit}
		err := gotsrpc.LoadArgs(&args, callStats, r)
		if err != nil {
			gotsrpc.ErrorCouldNotLoadArgs(w)
			return
		}
		executionStart := time.Now()
		setUnitState, setUnitErr := p.service.SetUnit(w, r, arg_unit)
		if callStats != nil {
			callStats.Execution = time.Now().Sub(executionStart)
		}
		gotsrpc.Reply([]interface{}{setUnitState, setUnitErr}, callStats, r, w)
		return
	case "SetVerbConjugation":
		var (
			arg_conjugation github_com_janhalfar_vocablion_services.Conjugation
		)
		args = []interface{}{&arg_conjugation}
		err := gotsrpc.LoadArgs(&args, callStats, r)
		if err != nil {
			gotsrpc.ErrorCouldNotLoadArgs(w)
			return
		}
		executionStart := time.Now()
		setVerbConjugationState, setVerbConjugationErr := p.service.SetVerbConjugation(w, r, arg_conjugation)
		if callStats != nil {
			callStats.Execution = time.Now().Sub(executionStart)
		}
		gotsrpc.Reply([]interface{}{setVerbConjugationState, setVerbConjugationErr}, callStats, r, w)
		return
	case "SetVerbExcpetions":
		var (
			arg_praeteritum string
			arg_perfect     string
			arg_ppp         string
		)
		args = []interface{}{&arg_praeteritum, &arg_perfect, &arg_ppp}
		err := gotsrpc.LoadArgs(&args, callStats, r)
		if err != nil {
			gotsrpc.ErrorCouldNotLoadArgs(w)
			return
		}
		executionStart := time.Now()
		setVerbExcpetionsState, setVerbExcpetionsErr := p.service.SetVerbExcpetions(w, r, arg_praeteritum, arg_perfect, arg_ppp)
		if callStats != nil {
			callStats.Execution = time.Now().Sub(executionStart)
		}
		gotsrpc.Reply([]interface{}{setVerbExcpetionsState, setVerbExcpetionsErr}, callStats, r, w)
		return
	case "SetWord":
		var (
			arg_word string
		)
		args = []interface{}{&arg_word}
		err := gotsrpc.LoadArgs(&args, callStats, r)
		if err != nil {
			gotsrpc.ErrorCouldNotLoadArgs(w)
			return
		}
		executionStart := time.Now()
		setWordState, setWordErr := p.service.SetWord(w, r, arg_word)
		if callStats != nil {
			callStats.Execution = time.Now().Sub(executionStart)
		}
		gotsrpc.Reply([]interface{}{setWordState, setWordErr}, callStats, r, w)
		return
	default:
		gotsrpc.ClearStats(r)
		http.Error(w, "404 - not found "+r.URL.Path, http.StatusNotFound)
	}
}
